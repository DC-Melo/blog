TARGET:DAWN → SUNRISE → MORNING → NOON → AFTERNOON → SUNSET → EVENING → NIGHT → @20200515 → ??? ⇒ 
●: ⇒ 
●: ⇒ 
●: ⇒ 
TODO:@20200516 → ??? → @20200517 → ??? → @20200519 → ??? → @20200522 → ??? → @20200530 → ??? ⇒ @20200615 → ??? ⇒ 
mutt -s 12528-20Fri20-20200515 melo.dachor@gmail.com < /home/dc/2P/006-write/blog/12528-20Fri20-20200515

SUNRISE:
MORNING:
NOON:
AFTERNOON:
SUNSET:
EVENING:
NOTE:
SUNRISE:
Fri May 15 05:21:42 CST 2020
	A.getup
	不能在类申明中初始化静态成员变量，这是因为申明描述了如何分配内存，单并不分配内存，你可以使用这种格式来创建对象，从而分配内存，对于静态类成员，可以在类声明之外使用单独的语句进行初始化，这是应为静态成员是单独存储的，而不是对象的组成部分。
	析构函数将在定义对象的代码块执行完毕时调用，如果不这样，析构函数将在main函数执行完毕时调用，导致你无法在执行窗口关闭前看到析构函数显示的消息。
Fri May 15 07:58:36 CST 2020
	A.go to work
	fork create a child process
	especially. fork return two result.1.pid.返回值大于0，说明是父进程的返回 2.return 0.是子进程的返回。在程序中，根据pid来判断父进程和子进程
	fork的进程，全局变量无法共享，因为每个进程都有自己独立的变量。
	目前linux系统，在fork时，对变量读时共享，写时复制。共享物理地址，而非虚拟地址。
	t.可以在开机时，创建好明天博客的模板。今天的用更新。
	父子进程共享文件描述符，和mmap建立的进程映射区（进程间通讯）
	fork之后，父子进程那个先执行，取决于进程调度算法。
	fork后，0-3G的用户空间是相同的，系统空间不同。
	gdb在调试时需要给定进程ID，默认调试父进程。set follow-fork-mode child，子进程的跟踪，通过断点来跟踪。设置条件断点。

MORNING:
NOON:
AFTERNOON:
SUNSET:
EVENING:
NOTE:
